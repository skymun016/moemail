import { createDb, Db } from "./db"
import { emails, users } from "./schema"
import { eq, sql } from "drizzle-orm"
import { nanoid } from "nanoid"
import { getRequestContext } from "@cloudflare/next-on-pages"

/**
 * 自动邮箱生成器
 * 用于在创建用户时自动生成指定数量的邮箱
 */

export interface AutoEmailGenerationOptions {
  userId: string
  username: string
  maxEmails: number
  defaultDomain?: string
}

export interface GeneratedEmailResult {
  success: boolean
  generatedCount: number
  batchId: string
  emails: Array<{
    id: string
    address: string
    sequence: number
  }>
  errors?: string[]
}

/**
 * 生成邮箱地址命名规则
 * 格式: {username}-{sequence}@{domain}
 * 例如: john-001@moemail.app, john-002@moemail.app
 */
function generateEmailAddress(username: string, sequence: number, domain: string): string {
  const paddedSequence = sequence.toString().padStart(3, '0')
  return `${username}-${paddedSequence}@${domain}`
}

/**
 * 获取可用的邮箱域名
 */
async function getAvailableDomains(): Promise<string[]> {
  try {
    const env = getRequestContext().env
    const domainString = await env.SITE_CONFIG.get("EMAIL_DOMAINS")
    return domainString ? domainString.split(',').map(d => d.trim()) : ["moemail.app"]
  } catch (error) {
    console.error('Failed to get email domains:', error)
    return ["moemail.app"]
  }
}

/**
 * 检查邮箱地址是否已存在
 */
async function isEmailAddressExists(db: Db, address: string): Promise<boolean> {
  const existing = await db.query.emails.findFirst({
    where: eq(sql`LOWER(${emails.address})`, address.toLowerCase())
  })
  return !!existing
}

/**
 * 为用户自动生成邮箱
 */
export async function generateEmailsForUser(options: AutoEmailGenerationOptions): Promise<GeneratedEmailResult> {
  const { userId, username, maxEmails, defaultDomain } = options
  const db = createDb()
  const batchId = nanoid(16)
  const errors: string[] = []
  const generatedEmails: Array<{ id: string; address: string; sequence: number }> = []

  // 获取用户的到期时间
  const user = await db.query.users.findFirst({
    where: eq(users.id, userId),
    columns: {
      expiresAt: true
    }
  })

  if (!user) {
    return {
      success: false,
      generatedCount: 0,
      errors: ['用户不存在'],
      generatedEmails: [],
      batchId
    }
  }

  try {
    // 验证用户是否存在
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId)
    })

    if (!user) {
      return {
        success: false,
        generatedCount: 0,
        batchId,
        emails: [],
        errors: ['用户不存在']
      }
    }

    // 获取可用域名
    const availableDomains = await getAvailableDomains()
    const targetDomain = defaultDomain && availableDomains.includes(defaultDomain) 
      ? defaultDomain 
      : availableDomains[0]

    // 检查用户是否已有邮箱
    const existingEmails = await db.query.emails.findMany({
      where: eq(emails.userId, userId)
    })

    if (existingEmails.length > 0) {
      return {
        success: false,
        generatedCount: 0,
        batchId,
        emails: [],
        errors: ['用户已有邮箱，无法自动生成']
      }
    }

    // 生成邮箱
    for (let sequence = 1; sequence <= maxEmails; sequence++) {
      const address = generateEmailAddress(username, sequence, targetDomain)
      
      // 检查地址是否已存在
      if (await isEmailAddressExists(db, address)) {
        errors.push(`邮箱地址 ${address} 已存在，跳过生成`)
        continue
      }

      try {
        // 创建邮箱记录
        const emailData = {
          address,
          userId,
          createdAt: new Date(),
          expiresAt: new Date('9999-01-01T00:00:00.000Z'), // 永久有效
          isAutoGenerated: true,
          generationBatchId: batchId,
          emailSequence: sequence,
        }

        const result = await db.insert(emails)
          .values(emailData)
          .returning({ id: emails.id, address: emails.address })

        generatedEmails.push({
          id: result[0].id,
          address: result[0].address,
          sequence
        })

      } catch (error) {
        console.error(`Failed to create email ${address}:`, error)
        errors.push(`创建邮箱 ${address} 失败: ${error instanceof Error ? error.message : '未知错误'}`)
      }
    }

    return {
      success: generatedEmails.length > 0,
      generatedCount: generatedEmails.length,
      batchId,
      emails: generatedEmails,
      errors: errors.length > 0 ? errors : undefined
    }

  } catch (error) {
    console.error('Auto email generation failed:', error)
    return {
      success: false,
      generatedCount: 0,
      batchId,
      emails: [],
      errors: [`自动生成邮箱失败: ${error instanceof Error ? error.message : '未知错误'}`]
    }
  }
}

/**
 * 删除用户的所有自动生成邮箱
 */
export async function deleteAutoGeneratedEmails(userId: string): Promise<{ success: boolean; deletedCount: number; error?: string }> {
  try {
    const db = createDb()
    
    const result = await db.delete(emails)
      .where(
        sql`${emails.userId} = ${userId} AND ${emails.isAutoGenerated} = true`
      )
      .returning({ id: emails.id })

    return {
      success: true,
      deletedCount: result.length
    }
  } catch (error) {
    console.error('Failed to delete auto-generated emails:', error)
    return {
      success: false,
      deletedCount: 0,
      error: error instanceof Error ? error.message : '删除失败'
    }
  }
}

/**
 * 获取用户的自动生成邮箱统计
 */
export async function getUserAutoEmailStats(userId: string): Promise<{
  totalCount: number
  autoGeneratedCount: number
  manualCreatedCount: number
}> {
  try {
    const db = createDb()
    
    const [totalResult, autoResult] = await Promise.all([
      db.select({ count: sql<number>`count(*)` })
        .from(emails)
        .where(eq(emails.userId, userId)),
      db.select({ count: sql<number>`count(*)` })
        .from(emails)
        .where(sql`${emails.userId} = ${userId} AND ${emails.isAutoGenerated} = true`)
    ])

    const totalCount = Number(totalResult[0].count)
    const autoGeneratedCount = Number(autoResult[0].count)
    const manualCreatedCount = totalCount - autoGeneratedCount

    return {
      totalCount,
      autoGeneratedCount,
      manualCreatedCount
    }
  } catch (error) {
    console.error('Failed to get user email stats:', error)
    return {
      totalCount: 0,
      autoGeneratedCount: 0,
      manualCreatedCount: 0
    }
  }
}
